---
layout: page
title: Problem 3
mathjax: true
tags: [euler]
---

<h3 style="color: #8f5536; text-align: center">Largest prime factor</h3>

> <small><span style="font-size: 1rem; color: #90a959">The prime factors of 13195 are 5, 7, 13 and 29. <br>
> What is the largest prime factor of the number 600851475143 ?</span><br><br>
> <cite>[http://projecteuler.net/problem=3](http://projecteuler.net/problem=3)</cite></small>
{: style="background-color: #2d2d2d"}

#### The Easy Way

{% highlight Bash %}
$ factor 600851475143
600851475143: 71 839 1471 6857
{% endhighlight %}

GNU `coreutils` has a [`factor`](https://www.gnu.org/software/coreutils/manual/html_node/factor-invocation.html) command. If you are using a linux machine it is most likely already installed. On Mac's you can install `coreutils` using a package manager like [`homebrew`](http://brew.sh/).

#### Brute Force

First lets make a prime generator. A prime number is any number that is only divisible by 1 and and itself. For a truly naive approach, to check if $n$ is prime, you would check every number in the range of $[2, n)$.

For our naive approach, we will keep an array of primes we have found and check if $n$ is divisible by any prime. We can do this because any non-prime number that $n$ is divisible by, is itself divisible by a previously found prime, making $n$ also divisible by that prime. We will also limit our search to odd numbers.

{% highlight Javascript %}
var naivePrimeGen = (function() {
  var primes = [];

  // Returns if n is prime using trial division for previously found primes.
  function isPrime(n) {
    var pi = 1, // Skip checking if divisible by 2.
        prime = primes[pi];
    while (prime < n) {
      if (!(n % primes[pi])) return false;
      prime = primes[++pi]
    }
    return true;
  }

  // Returns the last prime by looking at the end of the primes array.
  function lastPrime() {
    return primes[primes.length - 1];
  }

  // Check odd numbers greater than last found prime until prime is found.
  // Add to primes array and returns found prime. */
  function next() {
    var i;
    if (primes.length === 0 || primes.length === 1) {
      primes.push(primes.length + 2);
      return primes.length + 1;
    }
    i = lastPrime() + 2;
    while (!isPrime(i)) {
      i+=2;
    };
    primes.push(i);
    return i;
  }

  return {
    next : next
  }
})();

var i = 0;
while(++i < 15) {
  console.log('i:', i, 'prime:', naivePrimeGen.next());
}

i: 1 prime: 2
i: 2 prime: 3
i: 3 prime: 5
i: 4 prime: 7
i: 5 prime: 11
i: 6 prime: 13
i: 7 prime: 17
i: 8 prime: 19
i: 9 prime: 23
i: 10 prime: 29
i: 11 prime: 31
i: 12 prime: 37
i: 13 prime: 41
i: 14 prime: 43
{% endhighlight %}

#### More Optimizations

The big optimization we can make is only checking if $n$ is divisible by numbers $\le \sqrt n$. This is because if $pq=n$ for $p$ and $q\neq 1$ and $\neq \sqrt n$, then $p$ or $q$ must be $\le \sqrt n$. If both $p$ and $q \gt \sqrt n$ it would contradict $\sqrt n \times \sqrt n = n$.

{% highlight Javascript %}
var lessNaivePrimeGen = (function() {
  var primes = [];

  // Returns if n is prime using trial division for previously found primes.
  // Only check up to floor(sqrt(n)).
  function isPrime(n) {
    var pi = 1, // Skip checking if divisible by 2.
        prime = primes[pi],
        limit = Math.floor(Math.sqrt(n));
    while (prime <= limit) {
      if (!(n % prime)) return false;
      prime = primes[++pi];
    }
    return true;
  }

  // Returns the last prime by looking at the end of the primes array.
  function lastPrime() {
    return primes[primes.length - 1];
  }

  // Check odd numbers greater than last found prime until prime is found.
  // Add to primes array and returns found prime.
  function next() {
    var i;
    if (primes.length === 0 || primes.length === 1) {
      primes.push(primes.length + 2);
      return primes.length + 1;
    }
    i = lastPrime() + 2;
    while (!isPrime(i)) {
      i+=2;
    };
    primes.push(i);
    return i;
  }

  return {
    next : next
  };
})();

var i = 0;
while(++i < 15) {
  console.log('i:', i, 'prime:', lessNaivePrimeGen.next());
}

i: 1 prime: 2
i: 2 prime: 3
i: 3 prime: 5
i: 4 prime: 7
i: 5 prime: 11
i: 6 prime: 13
i: 7 prime: 17
i: 8 prime: 19
i: 9 prime: 23
i: 10 prime: 29
i: 11 prime: 31
i: 12 prime: 37
i: 13 prime: 41
i: 14 prime: 43
{% endhighlight %}

Another optimization that we can make that reduces the number of $n$'s we need to check is all primes past $3$ can be generalized in the form $6i \pm 1$.

The proof for this generalization can be stated as:

Given a number, $n \gt 3$, dividing $n$ by $6$ gives you: <br>
$n = 6x + r$ ; $x$ is a non-negative integer and $r$ is the remainder

----
for $r$ is $0$, $2$, or $4$ ; $n$ is divisible by $2$ <br>
for $r$ is $3$ ; $n$ is divisible by $3$

----
for $r$ is $1$ ; $n$ is $1$ more than a multiple of $6$ <br>
for $r$ is $5$ ; $n$ is $1$ less than a multiple of $6$

That means for all $n$ not in for form of $6i \pm 1$, $n$ is divisible by $2$ or $3$. This means we can eliminate all those from our checks.

{% highlight Javascript %}
var primeGen = (function() {
  var primes = [],
      i = 0, candidates = [];

  // Returns if n is prime using trial division for previously found primes.
  // Only check up to floor(sqrt(n)).
  function isPrime(n) {
    var j = 1, // Skip checking if divisible by 2.
        prime = primes[j],
        limit = Math.floor(Math.sqrt(n));
    while (prime <= limit) {
      if (!(n % prime)) return false;
      prime = primes[++j];
    }
    return true;
  }

  // Check odd numbers greater than last found prime until prime is found.
  // Add to primes array and returns found prime.
  function next() {
    if (primes.length === 0 || primes.length === 1) {
      primes.push(primes.length + 2);
      return primes.length + 1;
    }
    while (true) {
      var candidate = candidates.pop();
      while (candidate) {
        if (isPrime(candidate)) {
          primes.push(candidate);
          return candidate;
        }
        candidate = candidates.pop();
      }
      i++;
      candidates.push(6*i+1);
      candidates.push(6*i-1);
    }
  }

  return {
    next : next
  };
})();

var i = 0;
while(++i < 15) {
  console.log('i:', i, 'prime:', primeGen.next());
}

i: 1 prime: 2
i: 2 prime: 3
i: 3 prime: 5
i: 4 prime: 7
i: 5 prime: 11
i: 6 prime: 13
i: 7 prime: 17
i: 8 prime: 19
i: 9 prime: 23
i: 10 prime: 29
i: 11 prime: 31
i: 12 prime: 37
i: 13 prime: 41
i: 14 prime: 43
{% endhighlight %}

#### Using the Prime Generator

To find the prime factors for our number, we can apply the same logic we did for checking primes for divisibility by only checking up to $\sqrt n$.

{% highlight Javascript %}
var euler = (function(primeGen) {
  var factors = [],
      n = 600851475143,
      limit = Math.floor(Math.sqrt(n)),
      p = primeGen.next();
  while (p <= limit) {
    if (n % p === 0) factors.push(p);
    p = primeGen.next();
  }
  return factors;
})(primeGen);

console.log(euler);
[ 71, 839, 1471, 6857 ]
{% endhighlight %}
